<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometr√≠a Avanzada - Figuras Complejas</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=STIX+Two+Math&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            color: #333;
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            animation: fadeInDown 0.8s ease;
        }
        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .section {
            margin-bottom: 40px;
            background: rgba(255, 255, 255, 0.98);
            padding: 35px;
            border-radius: 25px;
            box-shadow: 0 15px 50px rgba(0,0,0,0.25);
            animation: fadeInUp 0.8s ease;
        }
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .section-title {
            font-size: 30px;
            color: #667eea;
            margin-bottom: 30px;
            text-align: center;
            font-weight: bold;
            position: relative;
            padding-bottom: 15px;
        }
        .section-title::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 4px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 2px;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 25px;
        }
        .figure-card {
            background: white;
            border: 3px solid transparent;
            border-radius: 20px;
            padding: 25px;
            text-align: center;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
        }
        .figure-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.15), transparent);
            transition: left 0.6s;
        }
        .figure-card:hover::before {
            left: 100%;
        }
        .figure-card:hover {
            transform: translateY(-12px) scale(1.03);
            box-shadow: 0 20px 40px rgba(102, 126, 234, 0.4);
            border-color: #667eea;
        }
        .figure-title {
            font-weight: bold;
            font-size: 19px;
            margin-bottom: 18px;
            color: #2c3e50;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .figure-container {
            width: 100%;
            height: 180px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 18px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
            padding: 15px;
            position: relative;
            overflow: hidden;
        }
        .figure-svg {
            width: 100%;
            height: 100%;
            max-width: 180px;
            max-height: 180px;
            transition: transform 0.4s ease;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.1));
        }
        .figure-card:hover .figure-svg {
            transform: scale(1.1);
        }
        .formula {
            font-family: 'STIX Two Math', 'Times New Roman', serif;
            font-size: 14px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 14px;
            border-radius: 10px;
            margin-top: 12px;
            line-height: 1.7;
            font-weight: 500;
            letter-spacing: 0.5px;
        }
        .frac {
            display: inline-block;
            vertical-align: middle;
            margin: 0 0.2em;
            text-align: center;
            font-size: 0.9em;
            line-height: 1.2;
        }
        .frac-numer {
            display: block;
            border-bottom: 2px solid white;
            padding: 0 0.3em;
        }
        .frac-denom {
            display: block;
            padding: 0.1em 0.3em 0;
        }
        .frac sub, .frac sup {
            font-size: 0.8em;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.9);
            justify-content: center;
            align-items: center;
            padding: 20px;
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .modal-content {
            background: white;
            border-radius: 25px;
            padding: 40px;
            max-width: 95%;
            max-height: 95vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 25px 80px rgba(0,0,0,0.6);
            animation: slideUp 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(100px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        .close {
            position: absolute;
            top: 20px;
            right: 30px;
            font-size: 40px;
            color: #aaa;
            cursor: pointer;
            z-index: 2001;
            transition: all 0.3s ease;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(255,255,255,0.1);
        }
        .close:hover {
            color: #fff;
            background: #e74c3c;
            transform: rotate(90deg) scale(1.1);
        }
        .modal-figure-container {
            width: 100%;
            height: 500px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 30px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 20px;
            padding: 30px;
        }
        .modal-figure-svg {
            width: 100%;
            height: 100%;
            max-width: 500px;
            max-height: 500px;
        }
        .modal-3d-container {
            width: 100%;
            height: 550px;
            background: linear-gradient(135deg, #2c3e50 0%, #4a6491 100%);
            border-radius: 20px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.3);
        }
        .modal-3d-container canvas {
            border-radius: 20px;
        }
        .modal-formula {
            font-family: 'STIX Two Math', 'Times New Roman', serif;
            font-size: 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin-top: 30px;
            white-space: pre-wrap;
            text-align: center;
            line-height: 2;
            font-weight: 500;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
            letter-spacing: 0.5px;
        }
        .modal-formula .frac {
            font-size: 1em;
            line-height: 1.5;
        }
        .modal-formula .frac-numer {
            padding: 0.1em 0.4em;
        }
        .modal-formula .frac-denom {
            padding: 0.2em 0.4em 0;
        }
        .controls-hint {
            text-align: center;
            color: white;
            margin-top: 20px;
            font-size: 15px;
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        .fig-trapecio-isosceles { fill: #16a085; stroke: #138d75; stroke-width: 3; }
        .fig-deltoides { fill: #c0392b; stroke: #a93226; stroke-width: 3; }
        .fig-corona-poligonal { fill: #f39c12; stroke: #e67e22; stroke-width: 3; }
        .fig-ovalo { fill: #e74c3c; stroke: #c0392b; stroke-width: 3; }
        .fig-rosa-polar { fill: #e91e63; stroke: #c2185b; stroke-width: 2; }
        .fig-lunula {
            fill: url(#gradLunula);
            stroke: #c0392b;
            stroke-width: 3;
            filter: url(#dropShadow);
        }
        .aux-line { stroke: #7f8c8d; stroke-width: 2; stroke-dasharray: 6,4; fill: none; }
        .label { font-size: 14px; font-weight: bold; fill: #222; }
        .angle-arc { fill: none; stroke: #e74c3c; stroke-width: 1.5; }
        .angle-label { font-size: 12px; fill: #e74c3c; font-weight: bold; }
        .mini-3d-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            border-radius: 15px;
            overflow: hidden;
        }
        .mini-3d-container canvas {
            border-radius: 15px;
        }
        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
            h1 {
                font-size: 1.8em;
            }
            .section {
                padding: 20px;
            }
            .modal-content {
                padding: 25px;
            }
            .modal-3d-container {
                height: 400px;
            }
        }
        .loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            text-align: center;
        }
        .spinner {
            border: 4px solid rgba(255,255,255,0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî∑ Geometr√≠a Avanzada - Figuras Complejas üìä</h1>
        <div class="section">
            <div class="section-title">‚úèÔ∏è Figuras Planas Avanzadas</div>
            <div class="grid">
                <div class="figure-card" onclick="openModal('trapecio_isosceles')">
                    <div class="figure-title">Trapecio Is√≥sceles</div>
                    <div class="figure-container">
                        <svg class="figure-svg" viewBox="0 0 200 200">
                            <polygon points="50,50 150,50 170,130 30,130" class="fig-trapecio-isosceles"/>
                            <line x1="50" y1="50" x2="50" y2="130" class="aux-line"/>
                            <text x="100" y="45" text-anchor="middle" class="label">b</text>
                            <text x="100" y="145" text-anchor="middle" class="label">B</text>
                            <text x="40" y="90" text-anchor="middle" class="label">h</text>
                            <text x="25" y="90" text-anchor="middle" class="label">L</text>
                            <text x="175" y="90" text-anchor="middle" class="label">L</text>
                        </svg>
                    </div>
                    <div class="formula">P = B+b+2L<br>A = <div class="frac"><span class="frac-numer">(B+b)h</span><span class="frac-denom">2</span></div></div>
                </div>
                <div class="figure-card" onclick="openModal('deltoides')">
                    <div class="figure-title">Deltoides (Cometa)</div>
                    <div class="figure-container">
                        <svg class="figure-svg" viewBox="0 0 200 200">
                            <polygon points="100,40 150,80 100,160 50,80" class="fig-deltoides"/>
                            <line x1="50" y1="80" x2="150" y2="80" class="aux-line"/>
                            <line x1="100" y1="40" x2="100" y2="160" class="aux-line"/>
                            <text x="75" y="80" text-anchor="middle" class="label">d‚ÇÅ</text>
                            <text x="100" y="100" text-anchor="middle" class="label">d‚ÇÇ</text>
                            <text x="125" y="60" text-anchor="middle" class="label">a</text>
                            <text x="125" y="120" text-anchor="middle" class="label">b</text>
                        </svg>
                    </div>
                    <div class="formula">P = 2(a+b)<br>A = <div class="frac"><span class="frac-numer">d‚ÇÅ¬∑d‚ÇÇ</span><span class="frac-denom">2</span></div></div>
                </div>
                <div class="figure-card" onclick="openModal('corona_poligonal')">
                    <div class="figure-title">Corona Poligonal</div>
                    <div class="figure-container">
                        <svg class="figure-svg" viewBox="0 0 200 200">
                            <polygon points="100,30 150,50 170,100 150,150 100,170 50,150 30,100 50,50" class="fig-corona-poligonal"/>
                            <polygon points="100,60 130,75 140,100 130,125 100,140 70,125 60,100 70,75" fill="white" stroke="#e67e22" stroke-width="3"/>
                            <line x1="100" y1="100" x2="100" y2="30" class="aux-line"/>
                            <line x1="100" y1="100" x2="100" y2="60" class="aux-line"/>
                            <circle cx="100" cy="100" r="3" fill="#333"/>
                            <text x="105" y="45" text-anchor="start" class="label">R</text>
                            <text x="105" y="80" text-anchor="start" class="label">r</text>
                        </svg>
                    </div>
                    <div class="formula">A = A_ext - A_int<br>Depende del pol√≠gono</div>
                </div>
                <div class="figure-card" onclick="openModal('lunula')">
                    <div class="figure-title">L√∫nula de Hip√≥crates</div>
                    <div class="figure-container">
                        <svg class="figure-svg" viewBox="0 0 200 200">
                            <defs>
                                <linearGradient id="gradLunula" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#e74c3c;stop-opacity:0.85" />
                                    <stop offset="100%" style="stop-color:#c0392b;stop-opacity:0.95" />
                                </linearGradient>
                                <filter id="dropShadow" height="130%">
                                    <feGaussianBlur in="SourceAlpha" stdDeviation="2"/>
                                    <feOffset dx="1" dy="2" result="offsetblur"/>
                                    <feComponentTransfer>
                                        <feFuncA type="linear" slope="0.2"/>
                                    </feComponentTransfer>
                                    <feMerge>
                                        <feMergeNode/>
                                        <feMergeNode in="SourceGraphic"/>
                                    </feMerge>
                                </filter>
                            </defs>
                            <polygon points="30,150 130,150 130,50"
                                     fill="#ecf0f1" stroke="#95a5a6" stroke-width="2" stroke-linejoin="round"/>
                            <path d="M 120,150 L 120,140 L 130,140" fill="none" stroke="#7f8c8d" stroke-width="2"/>
                            <path d="M 130,50
                                     A 50,50 0 0,1 130,150
                                     A 70.71,70.71 0 0,0 130,50 Z"
                                  class="fig-lunula"/>
                            <path d="M 30,155 Q 80,185 130,155" class="aux-line"/>
                            <text x="145" y="105" text-anchor="middle" class="label" font-size="16">a</text>
                            <text x="80" y="175" text-anchor="middle" class="label" font-size="16">a</text>
                            <circle cx="30" cy="150" r="4" fill="#2c3e50"/>
                            <circle cx="130" cy="150" r="4" fill="#2c3e50"/>
                            <circle cx="130" cy="50" r="4" fill="#2c3e50"/>
                        </svg>
                    </div>
                    <div class="formula">
                        A<sub>l√∫nula</sub> = A<sub>tri√°ngulo</sub> = <div class="frac"><span class="frac-numer">a¬≤</span><span class="frac-denom">2</span></div>
                        <br>(Teorema de Hip√≥crates)
                    </div>
                </div>
                <div class="figure-card" onclick="openModal('espiral_arquimedes')">
                    <div class="figure-title">Espiral de Arqu√≠medes</div>
                    <div class="figure-container">
                        <svg class="figure-svg" viewBox="0 0 200 200">
                            <path d="m19 100h162m-81-81v162" stroke="#ccc" stroke-width="1"/>
                            <path d="m180 100c-1.3 24.4-12.1 46.8-29.8 62.7-16.9 15.2-39.3 23.4-62.7 22.1-21.7-1.2-42.4-10.9-57.2-27.6-13.7-15.5-21.2-36-19.8-57.2 1.3-19.8 10.2-38.5 25.3-51.7 14.1-12.3 32.6-18.9 51.7-17.6 17.7 1.2 34.5 9.3 46.3 23 10.9 12.7 16.7 29.3 15.3 46.3-1.2 15.7-8.6 30.6-20.8 40.8-11.3 9.5-25.9 14.4-40.8 13.1-13.7-1.2-26.5-7.7-35.4-18.5-8.1-9.9-12.2-22.6-10.8-35.4 1.2-11.7 7-22.6 16.2-30 8.5-6.7 19.2-9.9 30-8.6 9.7 1.2 18.6 6.2 24.5 14 5.4 7.1 7.7 16 6.3 24.5-1.2 7.9-5.5 14.8-11.7 19.1-5.7 4-12.6 5.4-19.1 4-5.8-1.2-10.8-4.7-13.6-9.5-2.5-4.3-3.2-9.3-1.8-13.6 1.2-3.9 4-6.8 7.2-8.2 2.9-1.2 6-0.9 8.2 0.5 2 1.3 2.9 3.2 2.7 5-0.2 1.6-1.4 2.7-2.7 2.7"
                                  fill="none" stroke="#3498db" stroke-width="3"/>
                        </svg>
                    </div>
                    <div class="formula">r = a + bŒ∏<br>Œ∏ en radianes</div>
                </div>
                <div class="figure-card" onclick="openModal('ovalo')">
                    <div class="figure-title">√ìvalo/Ovoide</div>
                    <div class="figure-container">
                        <svg class="figure-svg" viewBox="0 0 200 200">
                            <ellipse cx="100" cy="110" rx="60" ry="70" class="fig-ovalo"/>
                            <line x1="100" y1="110" x2="160" y2="110" class="aux-line"/>
                            <line x1="100" y1="110" x2="100" y2="40" class="aux-line"/>
                            <circle cx="100" cy="110" r="3" fill="#333"/>
                            <text x="130" y="105" text-anchor="middle" class="label">a</text>
                            <text x="105" y="75" text-anchor="start" class="label">b</text>
                        </svg>
                    </div>
                    <div class="formula">P ‚âà œÄ(a+b)<br>A = œÄab</div>
                </div>
                <div class="figure-card" onclick="openModal('rosa_polar')">
                    <div class="figure-title">Rosa Polar (n-p√©tala)</div>
                    <div class="figure-container">
                        <svg class="figure-svg" viewBox="0 0 200 200">
                            <g transform="translate(100,100)">
                                <path d="M 0,0 Q 30,0 30,-30 Q 30,-60 0,-60 Q -30,-60 -30,-30 Q -30,0 0,0"
                                      fill="#e91e63" fill-opacity="0.5" stroke="#c2185b" stroke-width="2"/>
                                <path d="M 0,0 Q 0,30 30,30 Q 60,30 60,0 Q 60,-30 30,-30 Q 0,-30 0,0"
                                      fill="#e91e63" fill-opacity="0.5" stroke="#c2185b" stroke-width="2"/>
                                <path d="M 0,0 Q 0,-30 -30,-30 Q -60,-30 -60,0 Q -60,30 -30,30 Q 0,30 0,0"
                                      fill="#e91e63" fill-opacity="0.5" stroke="#c2185b" stroke-width="2"/>
                                <path d="M 0,0 Q -30,0 -30,30 Q -30,60 0,60 Q 30,60 30,30 Q 30,0 0,0"
                                      fill="#e91e63" fill-opacity="0.5" stroke="#c2185b" stroke-width="2"/>
                            </g>
                            <circle cx="100" cy="100" r="3" fill="#333"/>
                        </svg>
                    </div>
                    <div class="formula">r = cos(kŒ∏)<br>k p√©talos si k impar<br>2k si k par</div>
                </div>
            </div>
        </div>
        <div class="section">
            <div class="section-title">üì¶ S√≥lidos en el Espacio - Avanzados</div>
            <div class="grid">
                <div class="figure-card" onclick="open3DModal('paralelepipedo_oblicuo')">
                    <div class="figure-title">Paralelep√≠pedo Oblicuo</div>
                    <div class="figure-container">
                        <svg class="figure-svg" viewBox="0 0 600 500" preserveAspectRatio="xMidYMid meet">
                            <g>
                                <path d="M 325 115 L 425 165 L 525 115 L 425 65 Z" fill="#0a5f7d" fill-opacity="0.2" stroke="none"/>
                                <path d="M 175 435 L 275 385 L 525 115 L 425 165 Z" fill="#0a5f7d" fill-opacity="0.1" stroke="none"/>
                                <path d="M 75 385 L 175 435 L 425 165 L 325 115 Z" fill="#0a5f7d" fill-opacity="0.15" stroke="none"/>
                                <line x1="175" y1="335" x2="75" y2="385" stroke="#0a5f7d" stroke-width="3" stroke-dasharray="10,8"/>
                                <line x1="175" y1="335" x2="275" y2="385" stroke="#0a5f7d" stroke-width="3" stroke-dasharray="10,8"/>
                                <line x1="175" y1="335" x2="425" y2="65" stroke="#0a5f7d" stroke-width="3" stroke-dasharray="10,8"/>
                                <line x1="75" y1="385" x2="175" y2="435" stroke="#0a5f7d" stroke-width="3"/>
                                <line x1="175" y1="435" x2="275" y2="385" stroke="#0a5f7d" stroke-width="3"/>
                                <line x1="325" y1="115" x2="425" y2="165" stroke="#0a5f7d" stroke-width="3"/>
                                <line x1="425" y1="165" x2="525" y2="115" stroke="#0a5f7d" stroke-width="3"/>
                                <line x1="525" y1="115" x2="425" y2="65" stroke="#0a5f7d" stroke-width="3"/>
                                <line x1="425" y1="65" x2="325" y2="115" stroke="#0a5f7d" stroke-width="3"/>
                                <line x1="75" y1="385" x2="325" y2="115" stroke="#0a5f7d" stroke-width="3"/>
                                <line x1="175" y1="435" x2="425" y2="165" stroke="#0a5f7d" stroke-width="3"/>
                                <line x1="275" y1="385" x2="525" y2="115" stroke="#0a5f7d" stroke-width="3"/>
                            </g>
                        </svg>
                    </div>
                    <div class="formula" style="font-size: 12px; line-height: 1.5;">A = 2(ab+ac+bc)<br>V = A<sub>base</sub>¬∑h</div>
                </div>

                <div class="figure-card" onclick="open3DModal('cuna')">
                    <div class="figure-title">Cu√±a (Wedge)</div>
                    <div class="figure-container">
                        <svg class="figure-svg" viewBox="0 0 200 200">
                            <polygon points="160,160 160,60 60,160" fill="#c0392b" stroke="#a93226" stroke-width="2" stroke-linejoin="round"/>
                            <polygon points="60,160 160,60 130,35 30,135" fill="#e74c3c" stroke="#c0392b" stroke-width="2" stroke-linejoin="round"/>
                        </svg>
                    </div>
                    <div class="formula" style="font-size: 12px; line-height: 1.5;">V = <div class="frac"><span class="frac-numer">1</span><span class="frac-denom">2</span></div>abc<br>Prisma triangular cortado</div>
                </div>
                <div class="figure-card" onclick="open3DModal('tetraedro_truncado')">
                    <div class="figure-title">Tetraedro Truncado</div>
                    <div class="figure-container">
                        <div id="mini-tetraedro_truncado" class="mini-3d-container"></div>
                    </div>
                    <div class="formula" style="font-size: 11px; line-height: 1.4;">A = 7‚àö3¬∑a¬≤<br>V = <div class="frac"><span class="frac-numer">23‚àö2</span><span class="frac-denom">12</span></div>a¬≥</div>
                </div>
                <div class="figure-card" onclick="open3DModal('barril')">
                    <div class="figure-title">Barril (Tonel)</div>
                    <div class="figure-container">
                        <div id="mini-barril" class="mini-3d-container"></div>
                    </div>
                    <div class="formula" style="font-size: 12px; line-height: 1.5;">V ‚âà œÄh<div class="frac"><span class="frac-numer">(2D¬≤+d¬≤)</span><span class="frac-denom">12</span></div></div>
                </div>
                
                <div class="figure-card" onclick="open3DModal('cubo_truncado')">
                    <div class="figure-title">Cubo Truncado</div>
                    <div class="figure-container">
                        <svg class="figure-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 393 323">
                            <path d="M 360,212 L 356,212 L 353,220 L 308,263 L 309,269 L 312,267 L 315,270 L 312,272 L 317,272 L 323,281 L 328,281 Z" fill="#1abc9c" stroke="none"/>
                            <path d="M 89,62 L 31,121 L 31,219 L 89,295 L 173,307 L 231,248 L 231,151 L 172,74 Z" fill="#1abc9c" stroke="none"/>
                            <path d="M 220,15 L 124,22 L 131,25 L 132,34 L 137,34 L 139,44 L 142,42 L 154,58 L 155,67 L 165,69 Z" fill="#1abc9c" stroke="none"/>
                            <path d="M 324,52 L 273,70 L 235,151 L 235,248 L 273,303 L 323,285 L 309,258 L 368,203 L 368,105 Z" fill="#16a085" stroke="none"/>
                            <path d="M 69,35 L 90,58 L 156,66 L 122,17 L 119,22 L 113,20 L 107,26 L 98,25 L 96,30 L 92,27 L 87,33 L 72,38 L 72,34 Z" fill="#16a085" stroke="none"/>
                            <path d="M 170,69 L 273,65 L 321,45 L 306,24 L 222,12 Z" fill="#16a085" stroke="none"/>
                            <path d="M 67,277 L 75,285 L 71,281 L 72,279 L 69,279 Z" fill="#1abc9c" stroke="none"/>
                            <path d="M 64,273 L 66,275 L 68,274 Z" fill="#1abc9c" stroke="none"/>
                            <path d="M 55,260 L 61,268 L 62,266 L 60,263 L 58,263 Z" fill="#1abc9c" stroke="none"/>
                            <path d="M 271,307 L 235,255 L 230,255 L 178,308 L 228,309 L 220,309 L 220,305 L 249,306 L 240,308 L 253,304 Z" fill="#1abc9c" stroke="none"/>
                            <path d="M 269,69 L 177,74 L 233,146 Z" fill="#1abc9c" stroke="none"/>
                            <path d="M 66,39 L 65,48 L 56,58 L 59,61 L 48,75 L 50,73 L 51,78 L 41,90 L 44,91 L 43,95 L 36,100 L 39,101 L 33,107 L 35,111 L 85,60 Z" fill="#1abc9c" stroke="none"/>
                            <path d="M 328,282 L 326,282 L 327,284 Z" fill="#16a085" stroke="none"/>
                            <path d="M 124,255 L 221,250 L 162,174 Z" fill="#16a085" stroke="none"/>
                            <path d="M 273,305 L 231,249 L 173,310 Z" fill="#138d75" stroke="none"/>
                            <path d="M 29,219 L 64,272 L 87,297 Z" fill="#138d75" stroke="none"/>
                            <path d="M 367,203 L 328,283 L 329,286 Z" fill="#138d75" stroke="none"/>
                            <path d="M 273,68 L 173,73 L 234,150 Z" fill="#138d75" stroke="none"/>
                            <path d="M 329,49 L 328,51 L 350,83 L 367,104 Z" fill="#138d75" stroke="none"/>
                            <path d="M 68,36 L 28,120 L 87,62 L 86,55 Z" fill="#138d75" stroke="none"/>
                            <path d="M 307,25 L 306,26 L 325,46 L 327,46 Z" fill="#138d75" stroke="none"/>
                            <path d="M 88,297 L 172,311 L 171,308 Z" fill="#0e6655" stroke="none"/>
                            <path d="M 328,286 L 326,285 L 274,303 L 274,305 Z" fill="#0e6655" stroke="none"/>
                            <path d="M 77,272 L 75,271 L 72,273 L 75,274 Z" fill="#0e6655" stroke="none"/>
                            <path d="M 88,268 L 87,267 L 82,269 L 84,271 Z" fill="#0e6655" stroke="none"/>
                            <path d="M 93,265 L 94,267 L 96,267 L 99,264 Z" fill="#0e6655" stroke="none"/>
                            <path d="M 293,262 L 301,264 L 301,262 Z" fill="#0e6655" stroke="none"/>
                            <path d="M 110,261 L 104,261 L 105,263 Z" fill="#0e6655" stroke="none"/>
                            <path d="M 277,258 L 278,261 L 284,262 L 284,259 Z" fill="#0e6655" stroke="none"/>
                            <path d="M 260,256 L 260,258 L 267,259 L 268,257 Z" fill="#0e6655" stroke="none"/>
                            <path d="M 121,257 L 116,257 L 116,260 Z" fill="#0e6655" stroke="none"/>
                            <path d="M 243,254 L 244,256 L 251,257 L 250,254 Z" fill="#0e6655" stroke="none"/>
                            <path d="M 161,158 L 161,167 L 163,167 L 163,158 Z" fill="#0e6655" stroke="none"/>
                            <path d="M 234,151 L 232,151 L 233,249 Z" fill="#0e6655" stroke="none"/>
                            <path d="M 161,139 L 161,148 L 163,148 L 163,139 Z" fill="#0e6655" stroke="none"/>
                            <path d="M 161,119 L 161,128 L 163,128 L 163,119 Z" fill="#0e6655" stroke="none"/>
                            <path d="M 161,100 L 161,109 L 163,109 L 163,100 Z" fill="#0e6655" stroke="none"/>
                            <path d="M 161,80 L 161,89 L 163,89 L 163,80 Z" fill="#0e6655" stroke="none"/>
                            <path d="M 88,59 L 172,72 L 171,70 Z" fill="#0e6655" stroke="none"/>
                            <path d="M 328,48 L 323,48 L 273,66 L 274,68 L 321,52 Z" fill="#0e6655" stroke="none"/>
                            <path d="M 123,17 L 69,36 L 72,37 L 82,32 L 84,33 L 91,29 L 107,25 L 111,22 L 119,21 Z" fill="#0e6655" stroke="none"/>
                        </svg>
                    </div>
                    <div class="formula" style="font-size: 12px; line-height: 1.5;">A = 2(6+6‚àö3)a¬≤<br>V = (21+14‚àö2)a¬≥</div>
                </div>
                <div class="figure-card" onclick="open3DModal('cuboctaedro')">
                    <div class="figure-title">Cuboctaedro</div>
                    <div class="figure-container">
                        <svg class="figure-svg" viewBox="0 0 165 165">
                            <g fill-opacity=".5" stroke-linejoin="round">
                                <g stroke="#333">
                                    <path d="m29 153 33-33 50 41z" fill="#161"/>
                                    <path d="m29 153 33-33-25-66-33 16z" fill="#070"/>
                                    <path d="m4 70 33-16 25-50z" fill="#080"/>
                                    <path d="m62 4-25 50 75 16 24-50z" fill="#280"/>
                                    <path d="m112 70-50 50-25-66z" fill="#4c0"/>
                                    <path d="m112 70-50 50 50 41 49-66z" fill="#080"/>
                                    <path d="m112 70 24-50 25 75z" fill="#380"/>
                                    <path d="m161 95-49 66 33-33z" fill="#080"/>
                                </g>
                                <g stroke="#000">
                                <path d="m120 29 16-9-74-16z" fill="#850"/>
                                <path d="m120 29-66 82 91 17z" fill="#ce0"/>
                                <path d="m120 29-66 82-50-41 58-66z" fill="#080"/>
                                <path d="m120 29 25 99 16-33-25-75z" fill="#830"/>
                                <path d="m54 111 -25 42 83 8 33-33z" fill="#671"/>
                                <path d="m29 153-25-83 50 41z" fill="#252"/>
                                </g>
                            </g>
                        </svg>
                    </div>
                    <div class="formula" style="font-size: 12px; line-height: 1.5;">A = (6+2‚àö3)a¬≤<br>V = <div class="frac"><span class="frac-numer">5‚àö2</span><span class="frac-denom">3</span></div>a¬≥</div>
                </div>
                <div class="figure-card" onclick="open3DModal('piramide_pentagonal')">
                    <div class="figure-title">Pir√°mide Pentagonal</div>
                    <div class="figure-container">
                        <div id="mini-piramide_pentagonal" class="mini-3d-container"></div>
                    </div>
                    <div class="formula" style="font-size: 12px; line-height: 1.5;">V = (1/3)A_base¬∑h<br>A_base = (5/4)a¬≤cot(œÄ/5)</div>
                </div>
                <div class="figure-card" onclick="open3DModal('piramide_hexagonal')">
                    <div class="figure-title">Pir√°mide Hexagonal</div>
                    <div class="figure-container">
                        <div id="mini-piramide_hexagonal" class="mini-3d-container"></div>
                    </div>
                    <div class="formula" style="font-size: 12px; line-height: 1.5;">V = (1/3)A_base¬∑h<br>A_base = (3‚àö3/2)a¬≤</div>
                </div>
                <div class="figure-card" onclick="open3DModal('bicupula')">
                    <div class="figure-title">Bic√∫pula Pentagonal Giroelongada</div>
                    <div class="figure-container">
                        <div id="mini-bicupula" class="mini-3d-container"></div>
                    </div>
                    <div class="formula" style="font-size: 12px; line-height: 1.5;">S√≥lido de Johnson J‚ÇÑ‚ÇÜ<br>20 tri√°ngulos equil√°teros</div>
                </div>
                <div class="figure-card" onclick="open3DModal('capsula')">
                    <div class="figure-title">C√°psula</div>
                    <div class="figure-container">
                        <div id="mini-capsula" class="mini-3d-container"></div>
                    </div>
                    <div class="formula" style="font-size: 12px; line-height: 1.5;">V = œÄr¬≤(h + 4r/3)<br>A = 2œÄr(2r + h)</div>
                </div>
                <div class="figure-card" onclick="open3DModal('cilindro_oblicuo')">
                    <div class="figure-title">Cilindro Oblicuo</div>
                    <div class="figure-container">
                        <div id="mini-cilindro_oblicuo" class="mini-3d-container"></div>
                    </div>
                    <div class="formula" style="font-size: 12px; line-height: 1.5;">V = œÄr¬≤h<br>A_lat = 2œÄrl</div>
                </div>
                <div class="figure-card" onclick="open3DModal('cono_oblicuo')">
                    <div class="figure-title">Cono Oblicuo</div>
                    <div class="figure-container">
                        <div id="mini-cono_oblicuo" class="mini-3d-container"></div>
                    </div>
                    <div class="formula" style="font-size: 12px; line-height: 1.5;">V = (1/3)œÄr¬≤h<br>A_lat = œÄrl</div>
                </div>
                <div class="figure-card" onclick="open3DModal('esferoide')">
                    <div class="figure-title">Esferoide Prolato</div>
                    <div class="figure-container">
                        <div id="mini-esferoide" class="mini-3d-container"></div>
                    </div>
                    <div class="formula" style="font-size: 12px; line-height: 1.5;">V = (4/3)œÄab¬≤<br>Alargado (a > b)</div>
                </div>
                <div class="figure-card" onclick="open3DModal('esferoide_oblato')">
                    <div class="figure-title">Esferoide Oblato</div>
                    <div class="figure-container">
                        <div id="mini-esferoide_oblato" class="mini-3d-container"></div>
                    </div>
                    <div class="formula" style="font-size: 12px; line-height: 1.5;">V = (4/3)œÄa¬≤c<br>Achatado (a > c)</div>
                </div>
                <div class="figure-card" onclick="open3DModal('hiperboloide')">
                    <div class="figure-title">Hiperboloide de Revoluci√≥n</div>
                    <div class="figure-container">
                        <svg class="figure-svg" viewBox="0 0 200 250">
                            <!-- Superficie del hiperboloide -->
                            <path d="M 60 50 
                                     Q 90 125 60 200 
                                     A 40 10 0 0 0 140 200 
                                     Q 110 125 140 50 
                                     A 40 10 0 0 0 60 50 Z" 
                                  fill="#87ceeb" opacity="0.6" stroke="#5dade2" stroke-width="1"/>
                            
                            <!-- Lado izquierdo -->
                            <path d="M 60 50 Q 90 125 60 200" 
                                  fill="none" stroke="#5dade2" stroke-width="2" opacity="0.4"/>
                            
                            <!-- Lado derecho -->
                            <path d="M 140 50 Q 110 125 140 200" 
                                  fill="none" stroke="#87ceeb" stroke-width="2" opacity="0.4"/>
                            
                            <!-- Elipse inferior (discontinua) -->
                            <ellipse cx="100" cy="200" rx="40" ry="10" 
                                     fill="none" stroke="#2980b9" stroke-width="2.5"
                                     stroke-dasharray="6,4"/>
                            
                            <!-- Elipse superior (discontinua) -->
                            <ellipse cx="100" cy="50" rx="40" ry="10" 
                                     fill="none" stroke="#2980b9" stroke-width="2.5"
                                     stroke-dasharray="6,4"/>
                        </svg>
                    </div>
                    <div class="formula" style="font-size: 12px; line-height: 1.5;">(x¬≤/a¬≤) + (y¬≤/b¬≤) - (z¬≤/c¬≤) = 1</div>
                </div>
                <div class="figure-card" onclick="open3DModal('tronco_esfera')">
                    <div class="figure-title">Tronco de Esfera</div>
                    <div class="figure-container">
                        <div id="mini-tronco_esfera" class="mini-3d-container"></div>
                    </div>
                    <div class="formula" style="font-size: 12px; line-height: 1.5;">V = (œÄh/6)(3r‚ÇÅ¬≤ + 3r‚ÇÇ¬≤ + h¬≤)</div>
                </div>
            </div>
        </div>
    </div>
    <div id="modal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2 id="modal-title" class="section-title"></h2>
            <div id="modal-figure-container" class="modal-figure-container">
                <svg id="modal-figure-svg" class="modal-figure-svg" viewBox="0 0 200 200"></svg>
            </div>
            <div id="modal-formula" class="modal-formula"></div>
        </div>
    </div>
    <div id="modal3D" class="modal">
        <div class="modal-content">
            <span class="close" onclick="close3DModal()">&times;</span>
            <h2 id="modal3d-title" class="section-title"></h2>
            <div id="modal-3d-container" class="modal-3d-container"></div>
            <div id="modal3d-formula" class="modal-formula"></div>
            <p class="controls-hint">Usa el mouse para rotar | Zoom con rueda | Arrastra para mover</p>
        </div>
    </div>

    <script>
        let currentModal = null;
        let currentScene = null;
        let currentCamera = null;
        let currentRenderer = null;
        let currentControls = null;
        let currentMesh = null;
        let animationFrameId = null;
        let miniScenes = {};

        const shearMatrix = new THREE.Matrix4();
        shearMatrix.set(
            1, 0, 0, 0,
            0.5, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        );
        
        function createEdgeCircle(radius, yPos, isDashed, color = 0x2c3e50) {
            const segments = 64;
            const points = [];
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const y = yPos;
                const z = Math.sin(angle) * radius;
                points.push(new THREE.Vector3(x, y, z));
            }
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            geometry.applyMatrix4(shearMatrix);
            const material = isDashed
                ? new THREE.LineDashedMaterial({ color: color, linewidth: 2, dashSize: 0.15, gapSize: 0.08 })
                : new THREE.LineBasicMaterial({ color: color, linewidth: 2 });
            const line = isDashed ? new THREE.Line(geometry, material) : new THREE.LineLoop(geometry, material);
            if (isDashed) line.computeLineDistances();
            return line;
        }

        function createModalEdgeCircle(radius, yPos, isDashed) {
            return createEdgeCircle(radius, yPos, isDashed, 0xffffff);
        }

        function createSimpleEdgeCircle(radius, yPos, isDashed, color = 0x2c3e50) {
            const segments = 64;
            const points = [];
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const y = yPos;
                const z = Math.sin(angle) * radius;
                points.push(new THREE.Vector3(x, y, z));
            }
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = isDashed
                ? new THREE.LineDashedMaterial({ color: color, linewidth: 2, dashSize: 0.15, gapSize: 0.08 })
                : new THREE.LineBasicMaterial({ color: color, linewidth: 2 });
            const line = isDashed ? new THREE.Line(geometry, material) : new THREE.LineLoop(geometry, material);
            if (isDashed) line.computeLineDistances();
            return line;
        }

        function createSimpleModalEdgeCircle(radius, yPos, isDashed) {
            return createSimpleEdgeCircle(radius, yPos, isDashed, 0xffffff);
        }

        function createBarrelGeometry(topRadius = 0.7, maxRadius = 1.0, height = 2.0, segments = 32, heightSegments = 24) {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const indices = [];
            const normals = [];
            
            function getRadius(t) {
                const radiusDiff = maxRadius - topRadius;
                return maxRadius - radiusDiff * t * t;
            }
            
            for (let i = 0; i <= heightSegments; i++) {
                const v = i / heightSegments;
                const y = (v - 0.5) * height;
                const t = (v - 0.5) * 2;
                const radius = getRadius(t);
                
                for (let j = 0; j <= segments; j++) {
                    const u = j / segments;
                    const theta = u * Math.PI * 2;
                    
                    const x = Math.cos(theta) * radius;
                    const z = Math.sin(theta) * radius;
                    
                    vertices.push(x, y, z);
                    
                    const derivative = -2 * (maxRadius - topRadius) * t;
                    const nx = Math.cos(theta);
                    const ny = -derivative;
                    const nz = Math.sin(theta);
                    const len = Math.sqrt(nx*nx + ny*ny + nz*nz);
                    normals.push(nx/len, ny/len, nz/len);
                }
            }
            
            for (let i = 0; i < heightSegments; i++) {
                for (let j = 0; j < segments; j++) {
                    const a = i * (segments + 1) + j;
                    const b = a + segments + 1;
                    const c = a + 1;
                    const d = b + 1;
                    
                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }
            
            const bottomCenterIndex = vertices.length / 3;
            vertices.push(0, -height/2, 0);
            normals.push(0, -1, 0);
            
            for (let j = 0; j < segments; j++) {
                const a = j;
                const b = j + 1;
                indices.push(bottomCenterIndex, b, a);
            }
            
            const topCenterIndex = vertices.length / 3;
            vertices.push(0, height/2, 0);
            normals.push(0, 1, 0);
            
            const topRowStart = heightSegments * (segments + 1);
            for (let j = 0; j < segments; j++) {
                const a = topRowStart + j;
                const b = topRowStart + j + 1;
                indices.push(topCenterIndex, a, b);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setIndex(indices);
            
            return geometry;
        }

        function pushVertex(arr, x, y, z){
            arr.push(x, y, z);
            return (arr.length / 3) - 1;
        }
        function addTri(indices, a, b, c){ indices.push(a, b, c); }
        function addQuad(indices, a, b, c, d){ addTri(indices, a, b, c); addTri(indices, a, c, d); }

        function createGyroElongatedPentagonalBicupola(radius = 1.0, cupolaHeight = 0.45, prismHeight = 0.95) {
            const verts = [];
            const indices = [];

            const nPent = 5;
            const nDec = 10;
            const decRadius = radius * 1.6;

            const pentTop = [];
            const pentBottom = [];
            for(let i=0;i<nPent;i++){
                const ang = (i / nPent) * Math.PI * 2;
                const x = Math.cos(ang) * radius;
                const y = Math.sin(ang) * radius;
                const zTop = prismHeight/2 + cupolaHeight;
                const zBottom = - (prismHeight/2 + cupolaHeight);
                pentTop.push(pushVertex(verts, x, y, zTop));
                pentBottom.push(pushVertex(verts, x, y, zBottom));
            }

            const decTop = [];
            const decBottom = [];
            for(let i=0;i<nDec;i++){
                const ang = (i / nDec) * Math.PI * 2;
                decTop.push(pushVertex(verts, Math.cos(ang) * decRadius, Math.sin(ang) * decRadius, prismHeight/2));
            }
            for(let i=0;i<nDec;i++){
                const ang = ((i + 0.5) / nDec) * Math.PI * 2;
                decBottom.push(pushVertex(verts, Math.cos(ang) * decRadius, Math.sin(ang) * decRadius, -prismHeight/2));
            }

            for(let i=0;i<nDec;i++){
                const inext = (i+1) % nDec;
                addTri(indices, decTop[i], decBottom[i], decBottom[inext]);
                addTri(indices, decTop[i], decBottom[inext], decTop[inext]);
            }

            for(let i=0;i<nPent;i++){
                const dA = (2*i) % nDec;
                const dB = (2*i + 1) % nDec;
                const p = pentTop[i];
                addTri(indices, p, decTop[dA], decTop[dB]);
                const nextP = pentTop[(i+1)%nPent];
                const dC = (2*(i+1)) % nDec;
                addQuad(indices, decTop[dB], decTop[dC], nextP, p);
            }

            for(let i=0;i<nPent;i++){
                const dA = (2*i) % nDec;
                const dB = (2*i + 1) % nDec;
                const p = pentBottom[i];
                addTri(indices, p, decBottom[dB], decBottom[dA]);
                const nextP = pentBottom[(i+1)%nPent];
                const dC = (2*(i+1)) % nDec;
                addQuad(indices, decBottom[dA], decBottom[dC], nextP, p);
            }

            const centerTop = pushVertex(verts, 0, 0, prismHeight/2 + cupolaHeight + 0.0001);
            for(let i=0;i<nPent;i++){
                const a = pentTop[i];
                const b = pentTop[(i+1)%nPent];
                addTri(indices, centerTop, a, b);
            }
            const centerBottom = pushVertex(verts, 0, 0, - (prismHeight/2 + cupolaHeight) - 0.0001);
            for(let i=0;i<nPent;i++){
                const a = pentBottom[i];
                const b = pentBottom[(i+1)%nPent];
                addTri(indices, centerBottom, b, a);
            }

            const geometry = new THREE.BufferGeometry();
            const position = new Float32Array(verts);
            geometry.setAttribute('position', new THREE.BufferAttribute(position, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();

            return geometry;
        }

        function openModal(figura) {
            const modal = document.getElementById('modal');
            const titleElem = document.getElementById('modal-title');
            const svgContainer = document.getElementById('modal-figure-svg');
            const formulaDiv = document.getElementById('modal-formula');
            const modals = {
                'trapecio_isosceles': {
                    title: 'Trapecio Is√≥sceles',
                    svg: `<polygon points="30,30 170,30 200,170 0,170" class="fig-trapecio-isosceles"/>
<line x1="30" y1="30" x2="30" y2="170" class="aux-line"/>
<text x="100" y="25" text-anchor="middle" class="label">b</text>
<text x="100" y="185" text-anchor="middle" class="label">B</text>
<text x="15" y="100" text-anchor="middle" class="label">h</text>
<text x="-5" y="100" text-anchor="middle" class="label">L</text>
<text x="205" y="100" text-anchor="middle" class="label">L</text>`,
                    formula: 'Per√≠metro: P = B + b + 2L<br>√Årea: A = <div class="frac"><span class="frac-numer">(B+b)h</span><span class="frac-denom">2</span></div><br><br>Propiedades:<br>- Lados no paralelos iguales<br>- √Ångulos base iguales<br>- Diagonales iguales<br>- Sim√©trico'
                },
                'deltoides': {
                    title: 'Deltoides (Cometa)',
                    svg: `<polygon points="100,40 150,80 100,160 50,80" class="fig-deltoides"/>
<line x1="50" y1="80" x2="150" y2="80" class="aux-line"/>
<line x1="100" y1="40" x2="100" y2="160" class="aux-line"/>
<text x="75" y="80" text-anchor="middle" class="label">d‚ÇÅ</text>
<text x="100" y="100" text-anchor="middle" class="label">d‚ÇÇ</text>
<text x="125" y="60" text-anchor="middle" class="label">a</text>
<text x="125" y="120" text-anchor="middle" class="label">b</text>`,
                    formula: 'Per√≠metro: P = 2(a + b)<br>√Årea: A = <div class="frac"><span class="frac-numer">d‚ÇÅ ¬∑ d‚ÇÇ</span><span class="frac-denom">2</span></div><br><br>Propiedades:<br>- Dos pares de lados adyacentes iguales<br>- Diagonales perpendiculares<br>- Una diagonal es eje de simetr√≠a'
                },
                'corona_poligonal': {
                    title: 'Corona Poligonal',
                    svg: `<polygon points="100,10 160,30 180,90 160,150 100,170 40,150 20,90 40,30" class="fig-corona-poligonal"/>
<polygon points="100,40 140,55 150,90 140,125 100,140 60,125 50,90 60,55" fill="white" stroke="#e67e22" stroke-width="3"/>
<line x1="100" y1="90" x2="100" y2="10" class="aux-line"/>
<line x1="100" y1="90" x2="100" y2="40" class="aux-line"/>
<circle cx="100" cy="90" r="3" fill="#333"/>
<text x="105" y="25" text-anchor="start" class="label">R</text>
<text x="105" y="65" text-anchor="start" class="label">r</text>`,
                    formula: '√Årea: A = A_exterior - A_interior<br><br>Para pol√≠gonos regulares conc√©ntricos:<br>A = (n/2)(R¬≤ - r¬≤)sin(2œÄ/n)<br><br>Propiedades:<br>- n lados<br>- Conc√©ntrica<br>- Sim√©trica rotacional'
                },
                'lunula': {
                    title: 'L√∫nula de Hip√≥crates',
                    svg: `<defs>
                            <linearGradient id="gradLunulaModal" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#e74c3c;stop-opacity:0.9" />
                                <stop offset="100%" style="stop-color:#c0392b;stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <polygon points="30,150 130,150 130,50"
                                 fill="rgba(236, 240, 241, 0.6)" stroke="#bdc3c7" stroke-width="2"/>
                        <path d="M 120,150 L 120,140 L 130,140" fill="none" stroke="#95a5a6" stroke-width="2"/>
                        <path d="M 130,50 A 50,50 0 0,1 130,150 A 70.71,70.71 0 0,0 130,50 Z"
                              fill="url(#gradLunulaModal)" stroke="#c0392b" stroke-width="3"/>
                        <path d="M 30,150 Q 80,190 130,150" class="aux-line" style="stroke-dasharray: 4,4; opacity: 0.6;"/>
                        <text x="155" y="105" text-anchor="middle" class="label" font-size="14">a</text>
                        <text x="80" y="180" text-anchor="middle" class="label" font-size="14">a</text>
                        <circle cx="30" cy="150" r="3" fill="#2c3e50"/>
                        <circle cx="130" cy="150" r="3" fill="#2c3e50"/>
                        <circle cx="130" cy="50" r="3" fill="#2c3e50"/>`,
                    formula: 'A<sub>l√∫nula</sub> = <div class="frac"><span class="frac-numer">a¬≤</span><span class="frac-denom">2</span></div><br><br><strong>Descripci√≥n Geom√©trica:</strong><br>Esta configuraci√≥n muestra un tri√°ngulo rect√°ngulo is√≥sceles (gris) con catetos de longitud <em>a</em>. La l√∫nula roja se forma sobre uno de los catetos. Est√° delimitada exteriormente por una semicircunferencia (di√°metro = <em>a</em>) e interiormente por un arco de la circunferencia circunscrita al tri√°ngulo.'
                },
                'espiral_arquimedes': {
                    title: 'Espiral de Arqu√≠medes',
                    svg: `<path d="m19 100h162m-81-81v162" stroke="#ccc" stroke-width="1"/>
<path d="m180 100c-1.3 24.4-12.1 46.8-29.8 62.7-16.9 15.2-39.3 23.4-62.7 22.1-21.7-1.2-42.4-10.9-57.2-27.6-13.7-15.5-21.2-36-19.8-57.2 1.3-19.8 10.2-38.5 25.3-51.7 14.1-12.3 32.6-18.9 51.7-17.6 17.7 1.2 34.5 9.3 46.3 23 10.9 12.7 16.7 29.3 15.3 46.3-1.2 15.7-8.6 30.6-20.8 40.8-11.3 9.5-25.9 14.4-40.8 13.1-13.7-1.2-26.5-7.7-35.4-18.5-8.1-9.9-12.2-22.6-10.8-35.4 1.2-11.7 7-22.6 16.2-30 8.5-6.7 19.2-9.9 30-8.6 9.7 1.2 18.6 6.2 24.5 14 5.4 7.1 7.7 16 6.3 24.5-1.2 7.9-5.5 14.8-11.7 19.1-5.7 4-12.6 5.4-19.1 4-5.8-1.2-10.8-4.7-13.6-9.5-2.5-4.3-3.2-9.3-1.8-13.6 1.2-3.9 4-6.8 7.2-8.2 2.9-1.2 6-0.9 8.2 0.5 2 1.3 2.9 3.2 2.7 5-0.2 1.6-1.4 2.7-2.7 2.7"
                                  fill="none" stroke="#3498db" stroke-width="4"/>`,
                    formula: 'Ecuaci√≥n polar: r = a + bŒ∏<br><br>Longitud de arco: L = (b/2)[Œ∏‚àö(1+Œ∏¬≤) + ln(Œ∏ + ‚àö(1+Œ∏¬≤))]<br><br>Propiedades:<br>- Espaciamiento constante<br>- Usada en ingenier√≠a (compresores, espirales)'
                },
                'ovalo': {
                    title: '√ìvalo/Ovoide',
                    svg: `<ellipse cx="100" cy="110" rx="80" ry="90" class="fig-ovalo"/>
<line x1="100" y1="110" x2="180" y2="110" class="aux-line"/>
<line x1="100" y1="110" x2="100" y2="20" class="aux-line"/>
<circle cx="100" cy="110" r="3" fill="#333"/>
<text x="140" y="105" text-anchor="middle" class="label">a</text>
<text x="105" y="65" text-anchor="start" class="label">b</text>`,
                    formula: 'Per√≠metro aproximado: P ‚âà œÄ(a + b)<br>√Årea: A = œÄab<br><br>Para ovoide asim√©trico: f√≥rmulas m√°s complejas<br><br>Propiedades:<br>- Similar a elipse pero asim√©trica<br>- Usada en dise√±o (huevos, estadios)'
                },
                'rosa_polar': {
                    title: 'Rosa Polar (n-p√©tala)',
                    svg: `<g transform="translate(100,100)">
<path d="M 0,0 Q 40,0 40,-40 Q 40,-80 0,-80 Q -40,-80 -40,-40 Q -40,0 0,0" fill="#e91e63" fill-opacity="0.5" stroke="#c2185b" stroke-width="3"/>
<path d="M 0,0 Q 0,40 40,40 Q 80,40 80,0 Q 80,-40 40,-40 Q 0,-40 0,0" fill="#e91e63" fill-opacity="0.5" stroke="#c2185b" stroke-width="3"/>
<path d="M 0,0 Q 0,-40 -40,-40 Q -80,-40 -80,0 Q -80,40 -40,40 Q 0,40 0,0" fill="#e91e63" fill-opacity="0.5" stroke="#c2185b" stroke-width="3"/>
<path d="M 0,0 Q -40,0 -40,40 Q -40,80 0,80 Q 40,80 40,40 Q 40,0 0,0" fill="#e91e63" fill-opacity="0.5" stroke="#c2185b" stroke-width="3"/>
</g>
<circle cx="100" cy="100" r="4" fill="#333"/>`,
                    formula: 'Ecuaci√≥n: r = a cos(kŒ∏)<br><br>N√∫mero de p√©talos:<br>- k impar: k p√©talos<br>- k par: 2k p√©talos<br><br>√Årea: A = (k œÄ a¬≤)/4 para k impar<br><br>Usada en matem√°ticas polares'
                }
            };
            const data = modals[figura];
            if (data) {
                titleElem.textContent = data.title;
                svgContainer.setAttribute('viewBox', '0 0 200 200');
                svgContainer.innerHTML = data.svg;
                formulaDiv.innerHTML = data.formula;
                modal.style.display = "flex";
                document.body.style.overflow = 'hidden';
                currentModal = modal;
            }
        }

        function closeModal() {
            const modal = document.getElementById('modal');
            modal.style.display = "none";
            document.body.style.overflow = 'auto';
            currentModal = null;
        }

        function disposeMiniScenes() {
            Object.values(miniScenes).forEach(sceneData => {
                if (sceneData) {
                    if (sceneData.renderer.domElement.parentElement) {
                        sceneData.renderer.domElement.parentElement.innerHTML = '';
                    }
                    sceneData.renderer.dispose();
                }
            });
            miniScenes = {};
        }

        function initializeMini3DScenes() {
            const figures = [
                'tetraedro_truncado',
                'barril',
                'piramide_pentagonal', 'piramide_hexagonal', 'bicupula',
                'capsula',
                'cilindro_oblicuo', 'cono_oblicuo', 'esferoide', 'esferoide_oblato', 'tronco_esfera'
            ];
            figures.forEach(figura => {
                const container = document.getElementById(`mini-${figura}`);
                if (container) {
                    setupMini3DScene(container, figura);
                }
            });
        }

        function setupMini3DScene(container, figura) {
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f7fa);
            const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 5);
            camera.lookAt(0, 0, 0); // Asegurar que mira al centro
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.innerHTML = '';
            container.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            const r = 1.2, h = 2.5;

            if (figura === 'cilindro_oblicuo') {
                const geometry = new THREE.CylinderGeometry(r, r, h, 32);
                geometry.applyMatrix4(shearMatrix);

                const lateralMaterial = new THREE.MeshStandardMaterial({
                    color: 0xa8d5e2,
                    metalness: 0.2,
                    roughness: 0.6,
                    transparent: true,
                    opacity: 0.85
                });
                const baseMaterial = new THREE.MeshStandardMaterial({
                    color: 0xa8d5e2,
                    metalness: 0.2,
                    roughness: 0.6,
                    transparent: true,
                    opacity: 0.95
                });
                const mesh = new THREE.Mesh(geometry, [lateralMaterial, baseMaterial, baseMaterial]);
                mesh.position.set(0, 0, 0); // Centrar expl√≠citamente
                scene.add(mesh);

                scene.add(createEdgeCircle(r, h/2, true));
                scene.add(createEdgeCircle(r, -h/2, true));

            } else if (figura === 'cono_oblicuo') {
                const geometry = new THREE.ConeGeometry(r, h, 32);
                geometry.applyMatrix4(shearMatrix);

                const material = new THREE.MeshStandardMaterial({
                    color: 0xcc9900,
                    metalness: 0.2,
                    roughness: 0.6,
                    transparent: true,
                    opacity: 0.85
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(0, 0, 0); // Centrar expl√≠citamente
                scene.add(mesh);

                scene.add(createEdgeCircle(r, -h/2, true));
            } else if (figura === 'barril') {
                const geometry = createBarrelGeometry(0.9, 1.2, 2.5, 24, 18);
                const material = new THREE.MeshStandardMaterial({
                    color: 0xa67c52,
                    metalness: 0.2,
                    roughness: 0.6,
                    transparent: true,
                    opacity: 0.7
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(0, 0, 0); // Centrar expl√≠citamente
                scene.add(mesh);

                const edges = new THREE.EdgesGeometry(geometry, 15);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0x6b4423, linewidth: 2 });
                const wireframe = new THREE.LineSegments(edges, lineMaterial);
                mesh.add(wireframe);
            } else if (figura === 'bicupula') {
                const geometry = createGyroElongatedPentagonalBicupola(0.62, 0.35, 0.6);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x4aa3ff,
                    metalness: 0.2,
                    roughness: 0.5,
                    transparent: true,
                    opacity: 0.7
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(0, 0, 0); // Centrar expl√≠citamente
                scene.add(mesh);

                const edges = new THREE.EdgesGeometry(geometry);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0x022b3a, linewidth: 2 });
                const wireframe = new THREE.LineSegments(edges, lineMaterial);
                mesh.add(wireframe);
                camera.position.set(0, 0, 3.5);
                camera.lookAt(0, 0, 0); // Asegurar que mira al centro
            } else {
                let geometry;
                const colors = {
                    'tetraedro_truncado': 0x2ecc71,
                    'piramide_pentagonal': 0x8e44ad,
                    'piramide_hexagonal': 0xc0392b,
                    'capsula': 0xff6b6b,
                    'esferoide': 0xe91e63,
                    'esferoide_oblato': 0x9b59b6,
                    'tronco_esfera': 0x2ecc71
                };

                switch(figura) {
                    case 'tetraedro_truncado':
                        geometry = new THREE.IcosahedronGeometry(1.8, 0);
                        break;
                    case 'piramide_pentagonal':
                        geometry = new THREE.ConeGeometry(1.2, 2.5, 5);
                        break;
                    case 'piramide_hexagonal':
                        geometry = new THREE.ConeGeometry(1.2, 2.5, 6);
                        break;
                    case 'capsula': {
                        const group = new THREE.Group();
                        const cyl = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 1.5, 32), new THREE.MeshStandardMaterial({
                            color: 0xff6b6b, metalness: 0.2, roughness: 0.6, transparent: true, opacity: 0.7
                        }));
                        const sph1 = new THREE.Mesh(new THREE.SphereGeometry(0.6, 32, 16, 0, Math.PI*2, 0, Math.PI/2), new THREE.MeshStandardMaterial({
                            color: 0xff6b6b, metalness: 0.2, roughness: 0.6, transparent: true, opacity: 0.7
                        }));
                        sph1.position.y = 0.75;
                        const sph2 = new THREE.Mesh(new THREE.SphereGeometry(0.6, 32, 16, 0, Math.PI*2, Math.PI/2, Math.PI/2), new THREE.MeshStandardMaterial({
                            color: 0xff6b6b, metalness: 0.2, roughness: 0.6, transparent: true, opacity: 0.7
                        }));
                        sph2.position.y = -0.75;
                        group.add(cyl); group.add(sph1); group.add(sph2);
                        scene.add(group);
                        renderer.render(scene, camera);
                        miniScenes[figura] = { scene, renderer, mesh: group };
                        return;
                    }
                    case 'esferoide':
                        geometry = new THREE.SphereGeometry(1.2, 32, 32);
                        geometry.scale(1, 1.5, 1); // Prolato: alargado verticalmente
                        break;
                    case 'esferoide_oblato':
                        geometry = new THREE.SphereGeometry(1.2, 32, 32);
                        geometry.scale(1.5, 0.8, 1.5); // Oblato: achatado verticalmente, m√°s ancho
                        break;
                    case 'tronco_esfera':
                        // Radio de la esfera
                        const R_mini = 1.5;
                        // √Ångulos de corte: centrado en el ecuador, de 45¬∞ a 135¬∞
                        const thetaStart_mini = Math.PI * 45 / 180; // 45¬∞
                        const thetaLength_mini = Math.PI * 90 / 180; // 90¬∞ de apertura
                        
                        geometry = new THREE.SphereGeometry(R_mini, 32, 32, 0, Math.PI * 2, thetaStart_mini, thetaLength_mini);
                        
                        // Calcular radios y posiciones exactas de las tapas
                        const r_top_mini = R_mini * Math.sin(thetaStart_mini);
                        const y_top_mini = R_mini * Math.cos(thetaStart_mini);
                        const r_bottom_mini = R_mini * Math.sin(thetaStart_mini + thetaLength_mini);
                        const y_bottom_mini = R_mini * Math.cos(thetaStart_mini + thetaLength_mini);
                        
                        scene.add(createSimpleEdgeCircle(r_top_mini, y_top_mini, true));
                        scene.add(createSimpleEdgeCircle(r_bottom_mini, y_bottom_mini, true));
                        break;
                    default:
                        geometry = new THREE.BoxGeometry(2, 2, 2);
                }

                const material = new THREE.MeshStandardMaterial({
                    color: colors[figura] || 0x3498db,
                    metalness: 0.2,
                    roughness: 0.5,
                    transparent: true,
                    opacity: (figura === 'esferoide' || figura === 'esferoide_oblato' || figura === 'tronco_esfera') ? 0.85 : 0.7
                });
                const mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);

                if (figura !== 'esferoide' && figura !== 'esferoide_oblato' && figura !== 'tronco_esfera') {
                    const edges = new THREE.EdgesGeometry(geometry);
                    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
                    const wireframe = new THREE.LineSegments(edges, lineMaterial);
                    mesh.add(wireframe);
                }
            }

            renderer.render(scene, camera);
            miniScenes[figura] = { scene, renderer };
        }

        function open3DModal(figura) {
            disposeMiniScenes();
            const modal = document.getElementById('modal3D');
            const container = document.getElementById('modal-3d-container');
            const titleElem = document.getElementById('modal3d-title');
            const formulaDiv = document.getElementById('modal3d-formula');
            const titles = {
                'paralelepipedo_oblicuo': 'Paralelep√≠pedo Oblicuo',
                'cuna': 'Cu√±a (Wedge)',
                'tetraedro_truncado': 'Tetraedro Regular Truncado',
                'barril': 'Barril (Tonel)',
                'cubo_truncado': 'Cubo Truncado',
                'cuboctaedro': 'Cuboctaedro',
                'piramide_pentagonal': 'Pir√°mide Pentagonal',
                'piramide_hexagonal': 'Pir√°mide Hexagonal',
                'bicupula': 'Bic√∫pula Pentagonal Giroelongada',
                'capsula': 'C√°psula',
                'cilindro_oblicuo': 'Cilindro Oblicuo',
                'cono_oblicuo': 'Cono Oblicuo',
                'esferoide': 'Esferoide Prolato',
                'esferoide_oblato': 'Esferoide Oblato',
                'hiperboloide': 'Hiperboloide de Revoluci√≥n',
                'tronco_esfera': 'Tronco de Esfera (Zona Esf√©rica)'
            };
            titleElem.textContent = titles[figura] || figura;

            const formulas = {
                'paralelepipedo_oblicuo': `√Årea total: A = 2(ab+ac+bc)
<br>Volumen: V = A<sub>base</sub>¬∑h
<br><br>Donde:
<br>a, b, c = dimensiones
<br>h = altura perpendicular
<br><br>Principio de Cavalieri:
<br>El volumen se conserva con inclinaci√≥n`,
                'cuna': `Volumen: V = <div class="frac"><span class="frac-numer">1</span><span class="frac-denom">2</span></div>abc
<br><br>Donde:
<br>a = base
<br>b = profundidad
<br>c = altura
<br><br>Es un prisma triangular
<br>cortado en √°ngulo`,
                'tetraedro_truncado': `√Årea: A = 7‚àö3¬∑a¬≤
<br>Volumen: V = <div class="frac"><span class="frac-numer">23‚àö2</span><span class="frac-denom">12</span></div>a¬≥
<br><br>Caras:
<br>‚Ä¢ 4 hex√°gonos regulares
<br>‚Ä¢ 4 tri√°ngulos equil√°teros
<br><br>S√≥lido de Arqu√≠medes`,
                'barril': `Volumen: V ‚âà <div class="frac"><span class="frac-numer">œÄh</span><span class="frac-denom">12</span></div>(2D¬≤+d¬≤)
<br><br>Superficie: S ‚âà œÄ(D+d)¬∑‚àö[h¬≤+((D-d)/2)¬≤]
<br><br>Donde:
<br>D = di√°metro m√°ximo (centro)
<br>d = di√°metro de las bases
<br>h = altura
<br><br>F√≥rmula de Kepler (aproximaci√≥n)`,
                'cubo_truncado': `√Årea: A = 2(6+6‚àö3)a¬≤
<br>Volumen: V = (21+14‚àö2)a¬≥
<br><br>Caras:
<br>‚Ä¢ 8 tri√°ngulos equil√°teros
<br>‚Ä¢ 6 oct√≥gonos regulares
<br><br>S√≥lido de Arqu√≠medes
<br>14 caras totales`,
                'cuboctaedro': `√Årea: A = (6+2‚àö3)a¬≤
<br>Volumen: V = <div class="frac"><span class="frac-numer">5‚àö2</span><span class="frac-denom">3</span></div>a¬≥
<br><br>Caras:
<br>‚Ä¢ 8 tri√°ngulos equil√°teros
<br>‚Ä¢ 6 cuadrados
<br><br>Intersecci√≥n de cubo y octaedro
<br>S√≥lido de Arqu√≠medes`,
                'piramide_pentagonal': `Volumen: V = <div class="frac"><span class="frac-numer">1</span><span class="frac-denom">3</span></div>A<sub>base</sub>¬∑h
<br><br>Base pentagonal:
<br>A<sub>base</sub> = <div class="frac"><span class="frac-numer">5a¬≤‚àö(25+10‚àö5)</span><span class="frac-denom">4</span></div>
<br><br>√Årea lateral:
<br>A<sub>lat</sub> = <div class="frac"><span class="frac-numer">5¬∑a¬∑ap</span><span class="frac-denom">2</span></div>
<br><br>Donde ap = apotema lateral`,
                'piramide_hexagonal': `Volumen: V = <div class="frac"><span class="frac-numer">1</span><span class="frac-denom">3</span></div>A<sub>base</sub>¬∑h
<br><br>Base hexagonal:
<br>A<sub>base</sub> = <div class="frac"><span class="frac-numer">3‚àö3</span><span class="frac-denom">2</span></div>a¬≤
<br><br>√Årea lateral:
<br>A<sub>lat</sub> = <div class="frac"><span class="frac-numer">6¬∑a¬∑ap</span><span class="frac-denom">2</span></div>
<br><br>6 caras triangulares laterales`,
                'bicupula': `S√≥lido de Johnson J‚ÇÑ‚ÇÜ
<br><br>Composici√≥n:
<br>‚Ä¢ 2 c√∫pulas pentagonales
<br>‚Ä¢ 1 antiprisma pentagonal
<br><br>Caras:
<br>‚Ä¢ 30 tri√°ngulos
<br>‚Ä¢ 12 pent√°gonos
<br><br>Simetr√≠a: C‚ÇÖ·µ•
<br>Grupo puntual pentagonal`,
                'capsula': `Volumen: V = œÄr¬≤(h+<div class="frac"><span class="frac-numer">4r</span><span class="frac-denom">3</span></div>)
<br><br>√Årea: A = 2œÄr(2r+h)
<br><br>Composici√≥n:
<br>‚Ä¢ Cilindro central: altura h
<br>‚Ä¢ 2 semiesferas: radio r
<br><br>Usada en dise√±o farmac√©utico
<br>y modelado 3D`,
                'cilindro_oblicuo': `Volumen: V = œÄr¬≤h
<br>(h = altura perpendicular)
<br><br>√Årea lateral: A = 2œÄr l
<br>(l = longitud generatriz inclinada)
<br><br>Propiedades:
<br>- Bases paralelas pero no perpendiculares al eje
<br>- Secci√≥n transversal el√≠ptica si corte perpendicular`,
                'cono_oblicuo': `Volumen: V = <div class="frac"><span class="frac-numer">1</span><span class="frac-denom">3</span></div>œÄr¬≤h
<br>(h = altura perpendicular)
<br><br>√Årea lateral: A = œÄr l
<br>(l = ‚àö(r¬≤ + h¬≤) inclinada)
<br><br>Propiedades:
<br>- Apex no directamente sobre el centro de la base
<br>- Base circular, generatrices inclinadas`,
                'esferoide': `Volumen: V = <div class="frac"><span class="frac-numer">4</span><span class="frac-denom">3</span></div>œÄab¬≤
<br><br>Donde:
<br>a = eje mayor (vertical)
<br>b = eje menor (horizontal)
<br><br>Propiedades:
<br>- Alargado verticalmente (a > b)
<br>- Forma de bal√≥n de rugby o elipse vertical
<br>- Generado por rotaci√≥n de elipse alrededor del eje mayor`,
                'esferoide_oblato': `Volumen: V = <div class="frac"><span class="frac-numer">4</span><span class="frac-denom">3</span></div>œÄa¬≤c
<br><br>Donde:
<br>a = eje ecuatorial (horizontal)
<br>c = eje polar (vertical)
<br><br>Propiedades:
<br>- Achatado en los polos (a > c)
<br>- Forma similar a la Tierra
<br>- Generado por rotaci√≥n de elipse alrededor del eje menor`,
                'hiperboloide': `Ecuaci√≥n: (x¬≤/a¬≤) + (y¬≤/b¬≤) - (z¬≤/c¬≤) = 1
<br>Para revoluci√≥n: a = b
<br><br>√Årea superficial: integral compleja
<br>Volumen encerrado: depende del rango z
<br><br>Propiedades:
<br>- Superficie reglada
<br>- Usada en arquitectura (torres de enfriamiento)
<br>- Las l√≠neas discontinuas marcan el truncamiento`,
                'tronco_esfera': `Volumen: V = <div class="frac"><span class="frac-numer">œÄh</span><span class="frac-denom">6</span></div>(3r‚ÇÅ¬≤ + 3r‚ÇÇ¬≤ + h¬≤)
<br><br>√Årea lateral: A = 2œÄRh
<br>(R = radio de la esfera)
<br><br>Donde r‚ÇÅ, r‚ÇÇ = radios bases
<br>h = altura entre planos
<br><br>Propiedades:
<br>- Secci√≥n entre dos planos paralelos en esfera
<br>- Las l√≠neas discontinuas marcan base y tapa`
            };
            formulaDiv.innerHTML = formulas[figura] || "F√≥rmulas no disponibles";

            modal.style.display = "flex";
            document.body.style.overflow = 'hidden';
            currentModal = modal;
            setTimeout(() => {
                setup3DScene(container, figura);
            }, 100);
        }

        function createCuboctahedronGeometry(radius) {
            const vertices = [
                1, 1, 0,   1, -1, 0,  -1, 1, 0,  -1, -1, 0,
                1, 0, 1,   1, 0, -1,  -1, 0, 1,  -1, 0, -1,
                0, 1, 1,   0, 1, -1,  0, -1, 1,  0, -1, 1
            ];
            const scaledVertices = vertices.map(v => v * radius);
            const indices = [
                4, 8, 6, 4, 6, 10,  5, 11, 7, 5, 7, 9,
                0, 9, 2, 0, 2, 8,   1, 10, 3, 1, 3, 11,
                0, 4, 1, 0, 1, 5,   2, 7, 3, 2, 3, 6,
                0, 4, 8,  0, 5, 9,  1, 10, 4, 1, 5, 11,
                2, 8, 6,  2, 9, 7,  3, 6, 10, 3, 11, 7
            ];
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(scaledVertices, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            return geometry;
        }

        function createObliqueParallelepipedGeometry() {
            const A = [-1.0, 0, 0.5];
            const B = [0, 0, 1.0];
            const C = [1.0, 0, 0.5];
            const D = [0, 0, 0];
            const E = [1.5, 2.7, -1.8];
            const F = [2.5, 2.7, -1.3];
            const G = [3.5, 2.7, -1.8];
            const H = [2.5, 2.7, -2.3];

            const vertices = new Float32Array([
                ...A, ...B, ...C, ...D,
                ...E, ...F, ...G, ...H
            ]);

            const indices = [
                0, 1, 3,  1, 2, 3,
                4, 5, 7,  5, 6, 7,
                0, 1, 5,  0, 5, 4,
                1, 2, 6,  1, 6, 5,
                2, 3, 7,  2, 7, 6,
                3, 0, 4,  3, 4, 7
            ];

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            return geometry;
        }

        function createTruncatedCubeGeometry(radius) {
            const k = Math.sqrt(2) - 1;

            const raw = [
                1, 1, k, 1, 1, -k, 1, -1, k, 1, -1, -k,
                -1, 1, k, -1, 1, -k, -1, -1, k, -1, -1, -k,
                1, k, 1, 1, k, -1, 1, -k, 1, 1, -k, -1,
                -1, k, 1, -1, k, -1, -1, -k, 1, -1, -k, -1,
                k, 1, 1, k, 1, -1, k, -1, 1, k, -1, -1,
                -k, 1, 1, -k, 1, -1, -k, -1, 1, -k, -1, -1
            ];
            const verts = raw.map(v => v * radius);

            const idx = [];

            idx.push(16, 8, 0, 1, 9, 17, 2, 10, 18, 19, 11, 3,
                4, 12, 20, 21, 13, 5, 22, 14, 6, 7, 15, 23);

            function fan(center, ring) {
                for (let i = 0; i < ring.length - 1; i++) {
                    idx.push(center, ring[i], ring[i + 1]);
                }
            }
            fan(16, [20, 12, 14, 22, 18, 10, 8]);
            fan(17, [9, 11, 19, 23, 15, 13, 21]);
            fan(0, [8, 10, 2, 3, 11, 9, 1]);
            fan(4, [12, 14, 6, 7, 15, 13, 5]);
            fan(16, [0, 1, 17, 21, 5, 4, 20]);
            fan(18, [22, 6, 7, 23, 19, 3, 2]);

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
            geometry.setIndex(idx);
            geometry.computeVertexNormals();
            return geometry;
        }

        function setup3DScene(container, figura) {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            if (currentControls) {
                currentControls.dispose();
                currentControls = null;
            }
            if (currentRenderer) {
                if (currentRenderer.domElement && container.contains(currentRenderer.domElement)) {
                    container.removeChild(currentRenderer.domElement);
                }
                currentRenderer.dispose();
                currentRenderer = null;
            }

            currentScene = null;
            currentCamera = null;
            currentMesh = null;

            container.innerHTML = '<div class="loader"><div class="spinner"></div>Cargando modelo 3D...</div>';

            currentScene = new THREE.Scene();
            currentScene.background = new THREE.Color(0x2c3e50);
            currentCamera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            currentCamera.position.set(6, 5, 8);
            currentCamera.lookAt(0, 0, 0);
            currentRenderer = new THREE.WebGLRenderer({ antialias: true });
            currentRenderer.setSize(container.clientWidth, container.clientHeight);
            currentRenderer.setPixelRatio(window.devicePixelRatio);
            currentRenderer.shadowMap.enabled = true;

            container.innerHTML = '';
            container.appendChild(currentRenderer.domElement);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            currentScene.add(ambientLight);
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(5, 5, 5);
            directionalLight1.castShadow = true;
            currentScene.add(directionalLight1);
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-5, -5, -5);
            currentScene.add(directionalLight2);

            const r = 2.5, h = 5;
            
            if (figura === 'cilindro_oblicuo') {
                const geometry = new THREE.CylinderGeometry(r, r, h, 32);
                geometry.applyMatrix4(shearMatrix);

                const lateralMaterial = new THREE.MeshStandardMaterial({
                    color: 0xa8d5e2,
                    metalness: 0.2,
                    roughness: 0.6,
                    transparent: true,
                    opacity: 0.85
                });
                const baseMaterial = new THREE.MeshStandardMaterial({
                    color: 0xa8d5e2,
                    metalness: 0.2,
                    roughness: 0.6,
                    transparent: true,
                    opacity: 0.95
                });
                currentMesh = new THREE.Mesh(geometry, [lateralMaterial, baseMaterial, baseMaterial]);
                currentScene.add(currentMesh);

                currentScene.add(createModalEdgeCircle(r, h/2, true));
                currentScene.add(createModalEdgeCircle(r, -h/2, true));
            } else if (figura === 'cono_oblicuo') {
                const geometry = new THREE.ConeGeometry(r, h, 32);
                geometry.applyMatrix4(shearMatrix);

                const material = new THREE.MeshStandardMaterial({
                    color: 0xcc9900,
                    metalness: 0.2,
                    roughness: 0.6,
                    transparent: true,
                    opacity: 0.85
                });
                currentMesh = new THREE.Mesh(geometry, material);
                currentScene.add(currentMesh);

                currentScene.add(createModalEdgeCircle(r, -h/2, true));

            } else if (figura === 'barril') {
                const geometry = createBarrelGeometry(0.7, 1.0, 2.0, 32, 24);

                const mat = new THREE.MeshPhongMaterial({
                    color: 0xa67c52,
                    shininess: 30,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.78,
                    depthWrite: false
                });

                currentMesh = new THREE.Mesh(geometry, mat);
                currentScene.add(currentMesh);

                const edges = new THREE.EdgesGeometry(geometry, 15);
                const lineMat = new THREE.LineBasicMaterial({ color: 0x6b4423, linewidth: 2 });
                const wire = new THREE.LineSegments(edges, lineMat);
                currentMesh.add(wire);
                currentCamera.position.set(3.5, 2.5, 4);
                
            } else if (figura === 'bicupula') {
                const geometry = createGyroElongatedPentagonalBicupola(1.0, 0.45, 0.95);

                const mat = new THREE.MeshPhongMaterial({
                    color: 0x4aa3ff,
                    shininess: 80,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.78,
                    depthWrite: false
                });

                currentMesh = new THREE.Mesh(geometry, mat);
                currentScene.add(currentMesh);

                const edges = new THREE.EdgesGeometry(geometry);
                const lineMat = new THREE.LineBasicMaterial({ color: 0x022b3a, linewidth: 2 });
                const wire = new THREE.LineSegments(edges, lineMat);
                currentMesh.add(wire);

                currentMesh.rotation.x = -0.2;
                currentMesh.rotation.y = 0.6;
                currentCamera.position.set(4, 3, 5);
            } else if (figura === 'hiperboloide') {
                const pointsHypModal = [];
                const numPoints = 20; // M√°s puntos para mejor suavidad
                for (let i = 0; i <= numPoints; i++) {
                    let y = (i / numPoints) * 6 - 3; // y va de -3 a 3, sim√©trico
                    let x = Math.sqrt(0.5 + y * y * 0.15) * 0.8; // F√≥rmula ajustada para mejor forma
                    pointsHypModal.push(new THREE.Vector2(x, y));
                }
                const geometry = new THREE.LatheGeometry(pointsHypModal, 32);
                currentMesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({
                    color: 0x87ceeb,
                    metalness: 0.3,
                    roughness: 0.5,
                    flatShading: false,
                    transparent: true,
                    opacity: 0.7
                }));
                currentScene.add(currentMesh);
                
                // Calcular radios en los extremos
                const y_extreme = 3;
                const hypModalRadiusTop = Math.sqrt(0.5 + y_extreme * y_extreme * 0.15) * 0.8;
                const hypModalRadiusBottom = hypModalRadiusTop; // Sim√©trico
                
                // Agregar tapas cerradas al hiperboloide
                const capMaterial = new THREE.MeshStandardMaterial({
                    color: 0x87ceeb,
                    metalness: 0.3,
                    roughness: 0.5,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                
                const capTopGeometry = new THREE.CircleGeometry(hypModalRadiusTop, 32);
                const capTop = new THREE.Mesh(capTopGeometry, capMaterial);
                capTop.rotation.x = Math.PI / 2;
                capTop.position.y = 3;
                currentScene.add(capTop);
                
                const capBottomGeometry = new THREE.CircleGeometry(hypModalRadiusBottom, 32);
                const capBottom = new THREE.Mesh(capBottomGeometry, capMaterial);
                capBottom.rotation.x = Math.PI / 2;
                capBottom.position.y = -3;
                currentScene.add(capBottom);
                
                currentScene.add(createSimpleModalEdgeCircle(hypModalRadiusTop, 3, true));
                currentScene.add(createSimpleModalEdgeCircle(hypModalRadiusBottom, -3, true));
            } else if (figura === 'tronco_esfera') {
                // Radio de la esfera
                const R = 3;
                // √Ångulos de corte: centrado en el ecuador, de 45¬∞ a 135¬∞
                const thetaStart = Math.PI * 45 / 180; // 45¬∞
                const thetaLength = Math.PI * 90 / 180; // 90¬∞ de apertura
                
                const geometry = new THREE.SphereGeometry(R, 32, 32, 0, Math.PI * 2, thetaStart, thetaLength);
                currentMesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({
                    color: 0x2ecc71,
                    metalness: 0.3,
                    roughness: 0.5,
                    flatShading: false,
                    transparent: true,
                    opacity: 0.75
                }));
                currentScene.add(currentMesh);
                
                // Calcular radios y posiciones exactas de las tapas
                // Tapa superior (corte a 45¬∞)
                const r_top_modal = R * Math.sin(thetaStart);
                const y_top_modal = R * Math.cos(thetaStart);
                
                // Tapa inferior (corte a 135¬∞)
                const r_bottom_modal = R * Math.sin(thetaStart + thetaLength);
                const y_bottom_modal = R * Math.cos(thetaStart + thetaLength);
                
                // Agregar tapas cerradas al tronco de esfera
                const capMaterial = new THREE.MeshStandardMaterial({
                    color: 0x2ecc71,
                    metalness: 0.3,
                    roughness: 0.5,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                
                // Tapa superior
                const capTopGeometry = new THREE.CircleGeometry(r_top_modal, 32);
                const capTop = new THREE.Mesh(capTopGeometry, capMaterial);
                capTop.rotation.x = Math.PI / 2;
                capTop.position.y = y_top_modal;
                currentScene.add(capTop);
                
                // Tapa inferior
                const capBottomGeometry = new THREE.CircleGeometry(r_bottom_modal, 32);
                const capBottom = new THREE.Mesh(capBottomGeometry, capMaterial);
                capBottom.rotation.x = Math.PI / 2;
                capBottom.position.y = y_bottom_modal;
                currentScene.add(capBottom);
                
                // Bordes discontinuos
                currentScene.add(createSimpleModalEdgeCircle(r_top_modal, y_top_modal, true));
                currentScene.add(createSimpleModalEdgeCircle(r_bottom_modal, y_bottom_modal, true));
            } else {
                let geometry;
                switch(figura) {
                    case 'paralelepipedo_oblicuo':
                        geometry = createObliqueParallelepipedGeometry();
                        currentMesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({
                            color: 0x0a5f7d,
                            shininess: 60,
                            flatShading: false,
                            side: THREE.DoubleSide,
                            transparent: true,
                            opacity: 0.75,
                            depthWrite: false
                        }));
                        currentCamera.position.set(4, 3, 5);
                        currentCamera.lookAt(1.5, 1.35, -0.6);
                        break;
                    case 'cuna':
                        const vertices_cuna = new Float32Array([
                            -2, -2, -2,  2, -2, -2,  2, -2, 2,  -2, -2, 2,
                            -2, 2, -2,   2, 2, -2
                        ]);
                        const indices_cuna = [
                            0, 1, 2,  0, 2, 3,
                            0, 1, 5,  0, 5, 4,
                            1, 2, 5,  3, 0, 4,  3, 4, 5,  3, 5, 2
                        ];
                        geometry = new THREE.BufferGeometry();
                        geometry.setAttribute('position', new THREE.BufferAttribute(vertices_cuna, 3));
                        geometry.setIndex(indices_cuna);
                        geometry.computeVertexNormals();
                        currentMesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({
                            color: 0xe74c3c,
                            metalness: 0.3,
                            roughness: 0.5,
                            flatShading: false,
                            transparent: true,
                            opacity: 0.7,
                            side: THREE.DoubleSide
                        }));
                        break;
                    case 'tetraedro_truncado':
                        geometry = new THREE.IcosahedronGeometry(3.5, 0);
                        currentMesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({
                            color: 0x2ecc71,
                            metalness: 0.3,
                            roughness: 0.5,
                            flatShading: false,
                            transparent: true,
                            opacity: 0.7
                        }));
                        break;
                    case 'cubo_truncado':
                        geometry = createTruncatedCubeGeometry(2.5);
                        currentMesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({
                            color: 0x16a085,
                            metalness: 0.3,
                            roughness: 0.5,
                            flatShading: true,
                            transparent: true,
                            opacity: 0.85,
                            side: THREE.DoubleSide
                        }));
                        break;
                    case 'cuboctaedro':
                        geometry = createCuboctahedronGeometry(1.3);
                        currentMesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({
                            color: 0x44aa44,
                            shininess: 30,
                            flatShading: false,
                            side: THREE.DoubleSide
                        }));
                        currentCamera.position.set(4.0, 3.0, 4.0);
                        currentCamera.lookAt(0, 0, 0);
                        break;
                    case 'piramide_pentagonal':
                        geometry = new THREE.ConeGeometry(2.5, 5, 5);
                        currentMesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({
                            color: 0x8e44ad,
                            metalness: 0.3,
                            roughness: 0.5,
                            flatShading: false,
                            transparent: true,
                            opacity: 0.7
                        }));
                        break;
                    case 'piramide_hexagonal':
                        geometry = new THREE.ConeGeometry(2.5, 5, 6);
                        currentMesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({
                            color: 0xc0392b,
                            metalness: 0.3,
                            roughness: 0.5,
                            flatShading: false,
                            transparent: true,
                            opacity: 0.7
                        }));
                        break;
                    case 'capsula':
                        const groupCap = new THREE.Group();
                        const cylCap = new THREE.Mesh(
                            new THREE.CylinderGeometry(1.5, 1.5, 3, 32),
                            new THREE.MeshStandardMaterial({
                                color: 0xff6b6b,
                                metalness: 0.3,
                                roughness: 0.5,
                                flatShading: false,
                                transparent: true,
                                opacity: 0.7
                            })
                        );
                        const sph1Cap = new THREE.Mesh(
                            new THREE.SphereGeometry(1.5, 32, 16, 0, Math.PI*2, 0, Math.PI/2),
                            new THREE.MeshStandardMaterial({
                                color: 0xff6b6b,
                                metalness: 0.3,
                                roughness: 0.5,
                                flatShading: false,
                                transparent: true,
                                opacity: 0.7
                            })
                        );
                        sph1Cap.position.y = 1.5;
                        const sph2Cap = new THREE.Mesh(
                            new THREE.SphereGeometry(1.5, 32, 16, 0, Math.PI*2, Math.PI/2, Math.PI/2),
                            new THREE.MeshStandardMaterial({
                                color: 0xff6b6b,
                                metalness: 0.3,
                                roughness: 0.5,
                                flatShading: false,
                                transparent: true,
                                opacity: 0.7
                            })
                        );
                        sph2Cap.position.y = -1.5;
                        groupCap.add(cylCap);
                        groupCap.add(sph1Cap);
                        groupCap.add(sph2Cap);
                        currentMesh = groupCap;
                        break;
                    case 'esferoide':
                        geometry = new THREE.SphereGeometry(2.5, 32, 32);
                        geometry.scale(1, 1.5, 1); // Prolato: alargado verticalmente
                        currentMesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({
                            color: 0xe91e63,
                            metalness: 0.3,
                            roughness: 0.5,
                            flatShading: false,
                            transparent: true,
                            opacity: 0.85
                        }));
                        break;
                    case 'esferoide_oblato':
                        geometry = new THREE.SphereGeometry(2.5, 32, 32);
                        geometry.scale(1.5, 0.7, 1.5); // Oblato: achatado verticalmente, m√°s ancho
                        currentMesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({
                            color: 0x9b59b6,
                            metalness: 0.3,
                            roughness: 0.5,
                            flatShading: false,
                            transparent: true,
                            opacity: 0.85
                        }));
                        break;
                    default:
                        geometry = new THREE.BoxGeometry(4, 4, 4);
                        currentMesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({
                            color: 0x3498db,
                            metalness: 0.3,
                            roughness: 0.5,
                            flatShading: false,
                            transparent: true,
                            opacity: 0.7
                        }));
                }

                if (geometry && figura !== 'capsula' && figura !== 'esferoide' && figura !== 'esferoide_oblato' && figura !== 'hiperboloide' && figura !== 'tronco_esfera') {
                    const edgesGeometry = new THREE.EdgesGeometry(geometry);
                    let edgeColor = 0x000000;
                    if(figura === 'cuboctaedro') edgeColor = 0x003300;
                    if(figura === 'paralelepipedo_oblicuo') edgeColor = 0x003344;
                    if(figura === 'cubo_truncado') edgeColor = 0x0e6655;

                    const edgesMaterial = new THREE.LineBasicMaterial({
                        color: edgeColor,
                        linewidth: (figura === 'cuboctaedro' || figura === 'paralelepipedo_oblicuo' || figura === 'cubo_truncado') ? 2 : 3
                    });
                    const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
                    currentMesh.add(edges);
                }
            }

            currentMesh.castShadow = true;
            currentMesh.receiveShadow = true;
            currentScene.add(currentMesh);

            currentControls = new THREE.OrbitControls(currentCamera, currentRenderer.domElement);
            currentControls.enableDamping = true;
            currentControls.dampingFactor = 0.05;
            currentControls.screenSpacePanning = false;
            currentControls.minDistance = 3;
            currentControls.maxDistance = 20;
            currentControls.maxPolarAngle = Math.PI;

            if (figura === 'paralelepipedo_oblicuo') {
                 currentControls.target.set(1.5, 1.35, -0.6);
            }

            function animate() {
                animationFrameId = requestAnimationFrame(animate);
                currentControls.update();
                currentRenderer.render(currentScene, currentCamera);
            }
            animate();
            const handleResize = () => {
                if (currentCamera && currentRenderer && container && currentModal && currentModal.style.display === 'flex') {
                    const width = container.clientWidth;
                    const height = container.clientHeight;
                    currentCamera.aspect = width / height;
                    currentCamera.updateProjectionMatrix();
                    currentRenderer.setSize(width, height);
                }
            };
            window.addEventListener('resize', handleResize);
        }

        function close3DModal() {
            const modal = document.getElementById('modal3D');
            if (modal) {
                modal.style.display = "none";
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            if (currentRenderer) {
                const container = document.getElementById('modal-3d-container');
                if (container && currentRenderer.domElement && container.contains(currentRenderer.domElement)) {
                    container.removeChild(currentRenderer.domElement);
                }
                currentRenderer.dispose();
                currentRenderer = null;
            }
            if (currentControls) {
                currentControls.dispose();
                currentControls = null;
            }
            currentScene = null;
            currentCamera = null;
            currentMesh = null;
            initializeMini3DScenes();
            currentModal = null;
            document.body.style.overflow = 'auto';
        }

        window.onclick = function(event) {
            if (event.target === document.getElementById('modal')) {
                closeModal();
            } else if (event.target === document.getElementById('modal3D')) {
                close3DModal();
            }
        };

        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                if (currentModal) {
                    if (currentModal.id === 'modal') {
                        closeModal();
                    } else if (currentModal.id === 'modal3D') {
                        close3DModal();
                    }
                }
            }
        });
        window.addEventListener('beforeunload', () => {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            if (currentRenderer) currentRenderer.dispose();
            Object.values(miniScenes).forEach(sceneData => {
                if (sceneData.renderer) sceneData.renderer.dispose();
            });
        });
        window.addEventListener('load', initializeMini3DScenes);
    </script>
</body>
</html>
                